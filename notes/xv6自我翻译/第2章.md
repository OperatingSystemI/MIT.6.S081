## Operating system organization(操作系统组织)
A key requirement for an operating system is to support several activities at once. For example, using the system call interface described in Chapter 1 a process can start new processes with fork. The operating system must *time-share* the resources of the computer among these processes. For example, even if there are more processes than there are hardware CPUs, the operating system must ensure that all of the processes get a chance to execute. The operating system must also arrange for isolation between the processes. That is, if one process has a bug and malfunctions, it shouldn't affect processes that don't depend on the buggy process. Complete isolation, however, is too strong, since it should be possible for processes to intentionally interact; pipelines are an example. Thus an operating system must fulfill three requirements: multiplexing, isolation, and interaction.

对于操作系统，必须支持多任务。比如，使用第一章描述的操作系统接口，一个进程可以通过`fork`开启一个新的进程. 操作系统必须在这些进程间实时共享计算机的资源。比如， 即使进程数多于硬件的CPU数，操作系统必须确保所有的进程都有机会执行。操作系统必须安排进程之间的隔离。因为，如果一个进程出现bug和故障，得保证这个有故障的进程不会影响到不依赖他的进程。但是完全的隔离太绝对了，因为进程间有可能会有意地进行相互影响。`管道(pipelines)`就是一个例子。因此一个操作系统必须满足三个需求：1)多任务 2)隔离 3)相互作用

&emsp;&emsp;This chapter provides an overview of how operating systems are organized to achieve these three requirements. It turns out there are many ways to do so, but this text focuses on mainstream designs centered around a *monolitihic kernel*, which is used by many Unix operating systems. This chapter also provides an overview of an xv6 process, which is the unit of isolation in xc6, and the creation of the first process when xv6 starts. 

&emsp;&emsp;这一章是对操作系统如何实现上述三个需求的一个综述。 事实证明有许多方法可以做到，但是这个文章聚焦于主流的设计，中心围绕`宏内核monolitihic kernel`，一个被许多Unix操作系统使用的内核。这一章也是概述了xv6 进程——xv6中的隔离单元，以及当xv6启动时第一个进程的创建。

&emsp;&emsp;Xv6 runs on a *multi-core* **RISC-V** microprocessor, and much of its low-level functionality(for example, its process implementation) is specific to **RISC-V**. **RISC-V** is a 64-bit CPU, and xv6 is writeen in "LP64" C, which means long(L) and pointers(P) in the C programming language are 64 bits, but int is 32-bit. This book assumes the reader has done a bit of machine-level programmming on some architecture, and will introduce **RISC-V-specific** ideas as they come up. A useful reference for **RISC-V** is "The RISC-V Reader: An Open Architecture Atals" [12]. The user-level ISA[2] and the privileged architecture [1] are the official specifications.

&emsp;&emsp;Xv6 跑在一个多核RISC-V 微处理器上，它的许多低级功能是争对RISC-V定制的(比如它的进程实现)。RISC-V是一个64位CPU，并且xv6被写在"LP64"C上，L64表示在C语言编程中，L(long)和P(pointers)是64位，但是int是32位。这本书假设读者有进行过些机器级别的编程，并且会介绍RISC-V-specific在之后遇见的时候。 对于RISC-V,一个有用的参考文献是"RISC-V的读者：一个开源架构集合"。这个用户级 ISA 和 特权架构是官方规格。

&emsp;&emsp;The CPU in a complete computer is surrounded by supoort hardware, much of it in the form of I/O interfaces. Xv6 is written for supoort hardware simulated by qemu's "-machine virt" option. This includes RAM, a ROM containing boot code, a serial connection to the user's key-board/screen, and a disk for storage.

&emsp;&emsp; 一个完整电脑上的CPU周围是其他支持该CPU的硬件，他们中的大部分以I/O接口的形式支持CPU。Xv6是用来支持被qemu模拟的硬件。这包括RAM，包含启动代码的ROM，一系列和用户鼠标/屏幕进行连接的部分以及一个用来存储的磁盘。

## 2.1 Abstracting physical resources(抽象物理资源)
&emsp;&emsp;The first question one might ask when encountering an operating system is why have it at all? That is, one could implement the system calls in [[Figure 1.2]] as a library, with which applications link. In this plan, each application could even have its own library tailored to its needs. Applications could directly interact with hardware resources and use those resources in the best way for the application(e.g., to achieve high or predictable performance). Some operating systems for embedded devices or real-time systems are organized in this way.

&emsp;&emsp;人们遇到操作系统的第一个问题可能是为什么会有他呢？那是因为，它能够实现将第1章第2节中用过的的系统调用形成一个库，其他应用可以链接这个库从而使用系统调用。在这个计划中，每个应用设置可以通过需要裁剪他们自己的库。应用能直接和硬件资源进行交互以及用最好的方式使用这些资源(例如，可以实现效率高或者可预测的表现)。一些嵌入式设备上的操作系统或者实时操作系统以这种方式组织。

&emsp;&emsp;The downside of this library approcah is that, if there is more than one application running, the applications must be well-behaved. For example, each application must periodically give up the CPU so that other applications can run. Such a cooperative time-sharing scheme may be OK if all applications trust each other and have no bugs. It's more typical for applications to not trust each other, and to have bugs, so one often wants stronger isolation than cooperative scheme provides.

&emsp;&emsp;这个库方法的缺点是，如果有多个应用运行，这些应用必须表现良好。例如，每个应用必须定期地放弃占用CPU以便其他的应用能够运行。例如一个合作的分时策略可能成功，如果所有应用相互信任并且没有bug。但是一般应用之间并不会互相信任并且有不少bug，所以我们通常想要一个比合作策略隔离性更强的策略。

&emsp;&emsp;To achieve strong isolation it's helpful to forbid applications from directly accessing sensitive hardware resources, and instead to abstract the resources into services. For example, Unix applications interact with storage only through the file system's `open`, `read`, `write`, and `close` system calls, instead of reading and writing the disk directly. This provides the application with the conenience of pathnames, and it allows the operating system(as the implementer of the interface)to manage the disk. Even if isolation is not a concern, programs that interact intentionally(or just wish to keep out of each other's way) are likely to find a file system a more convenient abstraction than direct use of the disk.

&emsp;&emsp; 为了实现强隔离，禁止程序直接访问敏感的硬件资源是非常有效的方法。取而代之，可以将资源抽象成服务。比如，unix应用只能通过文件系统的`open`、`read`、`write`以及`close`系统调用影响存储，而不能直接读和写磁盘。这样提供给应用路径名读便利，并且运行操作系统（接口读实现者）管理磁盘。即便隔离不是问题，有意进行交互的程序（或者只是希望互相避开）很可能会发现比起直接使用磁盘，文件系统是更加便利的抽象。

&emsp;&emsp;Similarly, Unix transparently switches hardware CPUs among processes, saving and restoring register state as necessary, so that applications don't have to be aware of time sharing. This transparency allows the operating system to share CPUs even if some applications are in infinite loops;

&emsp;&emsp;类似的，unix在进程中透明地切换cpu(当然保存和和恢复寄存器状态是必要的)，以便应用不必感觉到时间共享。这种透明运行操作系统分享cpu，即使一些应用处于无限循环中。

&esmp;&emsp;As another example, Unix processes use `exec` to build up their memory image, instead of directly interacting with physical memory. This allows the operating system to decide where to place a process in memory; if memory is tight, the operating system might even store some of a process's data on disk. `Exec` also provides users with the convenience of a file system to store executable program images.

&emsp;&emsp;另一个例子，unix使用`exec`来创建他们的内存映像，而不是直接影响物理内存。这允许操作系统决定将一个进程放置在内存的何处。如果内存资源很紧张，操作系统甚至可以将一些进程的数据存入磁盘。`exec`也提供用户文件系统，以方便用户存储可执行程序映像。

&emsp;&emsp;Many forms of interaction among Unix processes occur via file descriptors. Not only do file descriptors abstract away many details(e.g, where data in a pipe or file is stored), they are also defined in a way that simplifies interaction. For example, if one application in a pipeline fails, the kernel generates an end-of-file signal for the next process in the pipeline.

&emsp;&emsp;unix中许多进程通过文件描述符进行交互。文件描述符不仅抽象掉许多细节(比如，管道数据在哪或文件被存在哪里)，它还被用来简化交互。比如，如果一个在管道中的应用挂掉了，内核会形成一个终结的标志给管道另一头的进程。

&emsp;&emsp;The system-call interface in [[Figure 1.2]] is carefully designed to provide both programmer convenience and the pssiblility of strong isolation. The Unix interface is not the only way to abstract resources, but it has proven to be a very good one.

&emsp;&emsp;第1章第2节的系统调用接口被精心设计出来，为了给编程者便利以及强隔离的可能性。unix接口并不是抽象资源的唯一方法，但是被证明是一个很好的方法。

## 2.2 User mode,supervisor mode, and system calls(用户模式，管理者模式，系统调用)
&emsp;&emsp;Strong isolation requires a hard boundary between applications an the operating system. If the application makes a mistake, we don't want the opearting system to fail or other applications to fail.

## 2.3 Kernel organization

## 2.4 Code: xv6 organization

## 2.5 Process overview

## 2.6 Code: starting xv6 and the first process

## 2.7 Real world

## 2.8 exercieses
