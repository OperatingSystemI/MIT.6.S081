## Operating system organization(操作系统组织)
A key requirement for an operating system is to support several activities at once. For example, using the system call interface described in Chapter 1 a process can start new processes with fork. The operating system must *time-share* the resources of the computer among these processes. For example, even if there are more processes than there are hardware CPUs, the operating system must ensure that all of the processes get a chance to execute. The operating system must also arrange for isolation between the processes. That is, if one process has a bug and malfunctions, it shouldn't affect processes that don't depend on the buggy process. Complete isolation, however, is too strong, since it should be possible for processes to intentionally interact; pipelines are an example. Thus an operating system must fulfill three requirements: multiplexing, isolation, and interaction.

对于操作系统，必须支持多任务。比如，使用第一章描述的操作系统接口，一个进程可以通过`fork`开启一个新的进程. 操作系统必须在这些进程间实时共享计算机的资源。比如， 即使进程数多于硬件的CPU数，操作系统必须确保所有的进程都有机会执行。操作系统必须安排进程之间的隔离。因为，如果一个进程出现bug和故障，得保证这个有故障的进程不会影响到不依赖他的进程。但是完全的隔离太绝对了，因为进程间有可能会有意地进行相互影响。`管道(pipelines)`就是一个例子。因此一个操作系统必须满足三个需求：1)多任务 2)隔离 3)相互作用

&emsp;&emsp;This chapter provides an overview of how operating systems are organized to achieve these three requirements. It turns out there are many ways to do so, but this text focuses on mainstream designs centered around a *monolitihic kernel*, which is used by many Unix operating systems. This chapter also provides an overview of an xv6 process, which is the unit of isolation in xc6, and the creation of the first process when xv6 starts. 

&emsp;&emsp;这一章是对操作系统如何实现上述三个需求的一个综述。 事实证明有许多方法可以做到，但是这个文章聚焦于主流的设计，中心围绕`宏内核monolitihic kernel`，一个被许多Unix操作系统使用的内核。这一章也是概述了xv6 进程——xv6中的隔离单元，以及当xv6启动时第一个进程的创建。

&emsp;&emsp;Xv6 runs on a *multi-core* **RISC-V** microprocessor, and much of its low-level functionality(for example, its process implementation) is specific to **RISC-V**. **RISC-V** is a 64-bit CPU, and xv6 is writeen in "LP64" C, which means long(L) and pointers(P) in the C programming language are 64 bits, but int is 32-bit. This book assumes the reader has done a bit of machine-level programmming on some architecture, and will introduce **RISC-V-specific** ideas as they come up. A useful reference for **RISC-V** is "The RISC-V Reader: An Open Architecture Atals" [12]. The user-level ISA[2] and the privileged architecture [1] are the official specifications.

&emsp;&emsp;Xv6 跑在一个多核RISC-V 微处理器上，它的许多低级功能是争对RISC-V定制的(比如它的进程实现)。RISC-V是一个64位CPU，并且xv6被写在"LP64"C上，L64表示在C语言编程中，L(long)和P(pointers)是64位，但是int是32位。这本书假设读者有进行过些机器级别的编程，并且会介绍RISC-V-specific在之后遇见的时候。 对于RISC-V,一个有用的参考文献是"RISC-V的读者：一个开源架构集合"。这个用户级 ISA 和 特权架构是官方规格。

&emsp;&emsp;The CPU in a complete computer is surrounded by supoort hardware, much of it in the form of I/O interfaces. Xv6 is written for supoort hardware simulated by qemu's "-machine virt" option. This includes RAM, a ROM containing boot code, a serial connection to the user's key-board/screen, and a disk for storage.

&emsp;&emsp; 一个完整电脑上的CPU周围是其他支持该CPU的硬件，他们中的大部分以I/O接口的形式支持CPU。Xv6是用来支持被qemu模拟的硬件。这包括RAM，包含启动代码的ROM，一系列和用户鼠标/屏幕进行连接的部分以及一个用来存储的磁盘。

## 2.1 Abstracting physical resources(抽象物理资源)
&emsp;&emsp;The first question one might ask when encountering an operating system is why have it at all? That is, one could implement the system calls in [[Figure 1.2]] as a library, with which applications link. In this plan, each application could even have its own library tailored to its needs. Applications could directly interact with hardware resources and use those resources in the best way for the application(e.g., to achieve high or predictable performance). Some operating systems for embedded devices or real-time systems are organized in this way.

&emsp;&emsp;人们遇到操作系统的第一个问题可能是为什么会有他呢？那是因为，它能够实现将第1章第2节中用过的的系统调用形成一个库，其他应用可以链接这个库从而使用系统调用。在这个计划中，每个应用设置可以通过需要裁剪他们自己的库。应用能直接和硬件资源进行交互以及用最好的方式使用这些资源(例如，可以实现效率高或者可预测的表现)。一些嵌入式设备上的操作系统或者实时操作系统以这种方式组织。

&emsp;&emsp;The downside of this library approcah is that, if there is more than one application running, the applications must be well-behaved. For example, each application must periodically give up the CPU so that other applications can run. Such a cooperative time-sharing scheme may be OK if all applications trust each other and have no bugs. It's more typical for applications to not trust each other, and to have bugs, so one often wants stronger isolation than cooperative scheme provides.

&emsp;&emsp;这个库方法的缺点是，如果有多个应用运行，这些应用必须表现良好。例如，每个应用必须定期地放弃占用CPU以便其他的应用能够运行。例如一个合作的分时策略可能成功，如果所有应用相互信任并且没有bug。但是一般应用之间并不会互相信任并且有不少bug，所以我们通常想要一个比合作策略隔离性更强的策略。

&emsp;&emsp;To achieve strong isolation it's helpful to forbid applications from directly accessing sensitive hardware resources, and instead to abstract the resources into services. For example, Unix applications interact with storage only through the file system's `open`, `read`, `write`, and `close` system calls, instead of reading and writing the disk directly. This provides the application with the conenience of pathnames, and it allows the operating system(as the implementer of the interface)to manage the disk. Even if isolation is not a concern, programs that interact intentionally(or just wish to keep out of each other's way) are likely to find a file system a more convenient abstraction than direct use of the disk.

&emsp;&emsp; 为了实现强隔离，禁止程序直接访问敏感的硬件资源是非常有效的方法。取而代之，可以将资源抽象成服务。比如，unix应用只能通过文件系统的`open`、`read`、`write`以及`close`系统调用影响存储，而不能直接读和写磁盘。这样提供给应用路径名读便利，并且运行操作系统（接口读实现者）管理磁盘。即便隔离不是问题，有意进行交互的程序（或者只是希望互相避开）很可能会发现比起直接使用磁盘，文件系统是更加便利的抽象。

&emsp;&emsp;Similarly, Unix transparently switches hardware CPUs among processes, saving and restoring register state as necessary, so that applications don't have to be aware of time sharing. This transparency allows the operating system to share CPUs even if some applications are in infinite loops;

&emsp;&emsp;类似的，unix在进程中透明地切换cpu(当然保存和和恢复寄存器状态是必要的)，以便应用不必感觉到时间共享。这种透明运行操作系统分享cpu，即使一些应用处于无限循环中。

&esmp;&emsp;As another example, Unix processes use `exec` to build up their memory image, instead of directly interacting with physical memory. This allows the operating system to decide where to place a process in memory; if memory is tight, the operating system might even store some of a process's data on disk. `Exec` also provides users with the convenience of a file system to store executable program images.

&emsp;&emsp;另一个例子，unix使用`exec`来创建他们的内存映像，而不是直接影响物理内存。这允许操作系统决定将一个进程放置在内存的何处。如果内存资源很紧张，操作系统甚至可以将一些进程的数据存入磁盘。`exec`也提供用户文件系统，以方便用户存储可执行程序映像。

&emsp;&emsp;Many forms of interaction among Unix processes occur via file descriptors. Not only do file descriptors abstract away many details(e.g, where data in a pipe or file is stored), they are also defined in a way that simplifies interaction. For example, if one application in a pipeline fails, the kernel generates an end-of-file signal for the next process in the pipeline.

&emsp;&emsp;unix中许多进程通过文件描述符进行交互。文件描述符不仅抽象掉许多细节(比如，管道数据在哪或文件被存在哪里)，它还被用来简化交互。比如，如果一个在管道中的应用挂掉了，内核会形成一个终结的标志给管道另一头的进程。

&emsp;&emsp;The system-call interface in [[Figure 1.2]] is carefully designed to provide both programmer convenience and the pssiblility of strong isolation. The Unix interface is not the only way to abstract resources, but it has proven to be a very good one.

&emsp;&emsp;第1章第2节的系统调用接口被精心设计出来，为了给编程者便利以及强隔离的可能性。unix接口并不是抽象资源的唯一方法，但是被证明是一个很好的方法。

## 2.2 User mode,supervisor mode, and system calls(用户模式，管理者模式，系统调用)
Strong isolation requires a hard boundary between applications an the operating system. If the application makes a mistake, we don't want the opearting system to fail or other applications to fail. Instead, the operating system should be able to clean up the failed application and continue running other applications. To achieve strong isolation, the operating system must arrange that applications cannot modify(or even read) the operating system's data structures and instructions and that applications cannot access other processes' memory.

强隔离需要在操作系统和应用之间设置一个牢固的边界。如果应用崩溃，我们不希望操作系统或者其他应用崩掉。相反，操作系统应该能够清理掉出错的应用并继续运行其他应用。为了实现强隔离，操作系统必须安排应用不能改变(甚至读)操作系统的数据结构和指令，并且应用不能访问其他应用的内存。

&emsp;&emsp;CPUs provide hardware support for strong isolation. For example, **RISC-V** has three modes in which the CPU can excute instructions: *machine mode*, *supervisor mode* and *user mode*. Instructions executing in machine mode have full privilege; a CPU starts in machine mode. Machine mode is mostly intended for configuring a computer. Xv6 executes a few lines in machine mode and then changes to supervisor mode.

&emsp;&emsp;cpu为强隔离提供了硬件支持。比如RISC-V处理器有三种模式，分别是机器模式、管理者模式和用户模式。在机器模式下执行指令有全部的权力；一个cpu以机器模式启动。机器模式主要用于配置计算机。Xv6 会在机器模式下执行几行代码然后变成管理者模式。

&emsp;&emsp;In supervisor mode the CPU is allowed to execute *privileged instructions*: for example, enabling and disabling interrupts, reading and writing the register that holds the address of a page table, etc. if an application in user mode attempts to execute a privileged instruction, then the CPU doesn't execute the instruction, but switches to supervisor mode so that supervisor-mode code can terminate the application, because it did something it shouldn't be doing. [[Figure1.1]]in Chapter 1 illustrates this organization. An application can execute only user-mode instructions(e.g., adding numbers, etc.)and is said to be running in *user space* while the software in supervisor mode can also execute privileged instructions and is said to be running in *kernel space*. The software running in kernel space(or in supervisor mode) is called the kernel.

&emsp;&emsp;在管理者模式下，cpu可以执行特权代码：比如，允许和禁止中断，读写寄存器并取得页表的地址等等。如果一个在用户模式下的应用试图执行特权代码，那么cpu不会执行这条指令，但是会切换到管理之模式，管理者模式代码能够终止这个应用，因为它做了些不应该做的事。第1章第1节用图表展示了这个组织。一个应用只能执行用户模式下的指令（比如，给一个数做加法，等等）并且据说跑在用户模式下，然而处于管理者模式下的软件也可也执行特权代码，并且跑在内核空间中。跑在内核空间（或处于管理者模式）的软件 被叫做内核。

&emsp;&emsp;An application that wants to invoke a kernel function(e.g., the `read` system call in xv6) must transition to the kernel. CPUs provide a special instruction that switches the CPU from user mode to supervisor mode and enters the kernel at an entry point specified by the kernel.(RISC-V provides the `ecall` instruction for this purpose.) Once the CPU has switched to supervisor mode, the kernel can then validate the arguments of the system call, decide whether the application is allowed to perform the requested operation, and then deny it or execute it. It is important that the kernel control the entry point for transitions to supervisor mode; if the application could decide the kernel entry point, a malicious applications could, for example, enter the kernel at a point where the validation of arguments is skipped.

&emsp;&emsp;一个应用想要唤起一个内核函数（比如xv6`read`系统调用）必须转换到内核。cpu提供特殊的指令将cpu从用户模式切换到管理者模式并且在一个由内核指定进入点进入内核。（为了达到这个目的，RISC-V 提供了`ecall`指令。）一旦cpu切换到管理者模式，内核就能使系统调用的参数生效，决定这个应用是否能执行这个被请求的操作，然后拒绝或执行它。在转换到管理者模式时，要内核来控制这个进入点是非常重要的；如果一个应用能决定这个内核的进入点，那么一个恶意的应用就能选择一个跳过有效的参数的进入点进入内核。

## 2.3 Kernel organization(内核组织)
A key design question is what part of the operating system should run in supervisor mode. One possiblity is that the entire operating system resides in the kernel, so that the implementations of all system calls run in supervisor mode. This organization is called a `monolithic kernel`.

一个关键的设计问题是操作系统的哪一部分应该运行在管理者模式下。一个可能的方法是将整个操作系统都放在内核里面，这样操作系统的所有实现都运行在管理者模式。这个组织形式被叫做`宏内核`。

&emsp;&emsp;In this organization the entire operating system runs with full hardware privilege. This organization is convenient because the OS designer doesn't have to decide which part of the operating system doesn't need full hardware privilege. Furthermore, it is easier for different parts of the operating system to coopearte. For example, an operating system might have a buffer cache that can be shared both by the file system and the virtual memory system.

&emsp;&emsp;在这个组织下，整个操作系统拥有全部的硬件特权。这种组织很方便，因为操作系统设计者不需要决定哪一部分不需要完整的硬件特权。此外，操作系统的不同部分更好合作。比如，一个操作系统一般由一个缓冲区缓存，它可以被文件系统和虚拟内存系统同时共享。

&emsp;&emsp;A downside of the monolithic organization is that the interfaces between different parts of the operating system are often complex (as we will see in the rest of this text), and therefore it is easy for an operating system developer to make a mistake. In a monolithic kernel, a mistake is fatal, because an error in supervisor mode will often cause the kernel to fail. If the kernel fails, the computer stops working, and thus all applications fail too. The computer must reboot to start again.

&emsp;&emsp;宏内核的一个缺点就是操作系统的不同部分的接口经常会很复杂（下面我们会看到），并且因此操作系统的开发者很容易制造错误。在宏内核中，出现一个错误会很严重，因为在管理者模式下的错误会导致内核崩溃。如果内核崩溃，计算机会停止工作，因此所有的应用也都会崩溃。计算机必须重启来解决问题。

![[Pasted image 20211019154152.png]]^Figure21

&emsp;&emsp;To reduce the risk of mistakes in the kernel, OS designers can minimize the amount of operating system code that runs in supervisor mode, and execute the bulk of the opearting system in user mode. This kernel organization is called a `microkernel`.

&emsp;&emsp;为了降低内核中出现错误的风险，操作系统的设计者可以尽量减少操作系统的代码量，并将大部分操作系统的代码放在用户模式下执行。这种内核组织形式被称为`微内核`。

&emsp;&emsp;[[第2章#^Figure21|Figure 2.1]] illustrates this microkernel design. In the figure, the file system runs as a user-level process. OS services running as processes are called servers. To allow applications to interact with the file server, the kernel provides an inter-process communication mechanism to send messages from one user-mode process to another. For example, if an application like the shell wants to read or write a file, it sends a message to the file server and watis for a response.

&emsp;&emsp;[[第2章#^Figure21|Figure 2.1]]用图表展示了微内核的设计。在这张图中，文件系统运行在用户级的经常中。操作系统服务运行在一个叫做服务的进程上。为了运行应用和文件服务器进行交互，内核提供了一个进程间通信机制，通过这个机制，用户模式下的进程可以发送信息给另一个进程。比如，如果一个应用比如shell想读写文件，它会发送一条信息给文件服务器然后等待响应。

&emsp;&emsp;In a microkernel, the kernel interface consists of a few low-level functions for starting applications, sending messages, accessing device hardware, etc. This organization allows the kernel to be relativeley simple, as most of the operating system resides in user-level servers.

&emsp;&emsp;在微内核中，内核的接口由一些低级的函数组成，这些函数用来启动应用，发送消息，访问设备硬件等等。这种组织形式允许内核相当的简单，因为大部分操作系统运行在用户级服务器中。

&emsp;&emsp;Xv6 is implemented as a monolithic kernel, like most Unix operating systems. Thus, the xv6 kernel interface corresponds to the operating system interface, and the kernel implements the complete operating system. Since xv6 doesn't provide many services, its kernel is smaller than some microkernels, but conceptually xv6 is monolithic.

&emsp;&emsp;xv6 被作为宏内核实现，像大部分unix操作系统一样。因此，xv6内核接口相当于操作系统接口，并且内核实现了完整的操作系统。因为xv6并没有提供太多服务，所以它的内核比一些微内核还小，但是定义上xv6是宏内核。

## 2.4 Code: xv6 organization(代码：xv6组织)
The xv6 kernel source is in `kernel/` sub-directory. The source is divided into files, following a rough notion of modularity; [[第2章#^d076c1|Figure2.2]] lists the files. The inter-module interfacces are defined in defs.h[(kernel/defs.h)](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/defs.h)

xv6的内核源码在`kernel/`子文件夹中。源码被分成很多文件，粗略地遵循某块化的概念；[[第2章#^d076c1|图片2.2]]列举了这些文件。模块间的接口被定义在def.h[(kernel/defs.h)](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/defs.h)。

## 2.5 Process overview(进程综述)
==Figure 2.2: Xv6 kernel source files.==

|File|Description|描述
|---|---|---|
|bio.c|Disk block cache for the file system|文件系统的磁盘块缓存|
|console.c|Connect to the user keyboard and screen|连接用户键盘和屏幕|
|entry.S|Very first boot instructions|第一个启动的命令|
|exec.c|ecec() system call|exec()系统调用|
|file.c|File descriptor support|文件描述符支持|
|fs.c|File system||
|kalloc.c|Physical page allocator||
|kernelvec.S|Handle traps from kernel, and timer interrupts||
|log.c|File system logging and crash recovery||
|main.c|Control initialization of other modules during boot||
|pipe.c|Pipes||
|plic.c|RISC-V interrupt controller||
|printf.c|Formatted output to the console||
|proc.c|Processes and scheduling||
|sleeplock.c|Locks that yield the CPU||
|spinlock.c|Locks that don't yield the CPU||
|start.c|Early machine-mode boot code||
|string.c|C string and byte-arry library||
|swtch.S|Thread switching||
|syscall.c|Dispatch system calls to handling function||
|sysfile.c|File-related system calls||
|trampoline.S|Assembly code to switch between user and kernel||
|trap.c|C code to handle and return from traps and interrupts||
|uart.c|Serial-port console device driver||
|virtio_disk.c|Disk device driver||
|vm.c|Manage page tables and address spaces||

^d076c1

The unit of isolation in xv6 (as in other Unix operating systems) is a *process*. The process abstraction prevents one process from wrecking or spying on another process's memory, CPU, file descriptors, etc. It also prevents a process from wrecking the kernel itself, so that a process can't subvert the kernel's isolation mechanisms. The kernel must implement the process abstraction with care because a buggy or malicious application may trick the kernel or hardware into doing something bad(e.g., circumventing isolation). The mechanisms used by the kernel to implement processes include the user/supervisor mode flag, address spaces, and time-slicing of threads.

xv6中的隔离单元(在其他操作系统也是)是进程。这个进程的抽象组织了一个进程破坏和监视其他进程的内存、cpu、文件描述符等等。它也阻止了进程破坏内核本身，这样一个进程就不会破坏内核的隔离机制了。内核必须仔细地实现进程的抽象，因为有bug或者恶意的应用很可能会诱使内核或硬件做一些不好的事（比如，规避隔离）。被内核用来实现进程的隔离机制包括用户/管理者模式，地址空间以及线程的时间分片。

&emsp;&emsp;To help enforce isolation, the process abstraction provides the illusion to a program that it has its own private machine. A process provides a program with what appears to be a private memory system, or *address space*, which other processes cannot read or write. A process also provides the program with what appears to be its own CPU to execute the program's instructions. 

&emsp;&emsp;为了帮助强制隔离，进程抽象让程序感觉他独占一台机器。进程提供程序一个看似私有都内存系统或地址空间（其他的经常不能读写）。进程也为程序提供一个看似属于他自己的cpu(这个cpu执行程序的指令)。

&emsp;&emsp;Xv6 uses page tables(which are implemented by hardware) to give each process its own address space. The RISC-V page table translates(or "maps") a *virtual address*(the address that an RISC-V instruction manipulates) to a *physical address*(an address that the CPU chip sends to main memory).

&emsp;&emsp;xv6使用页表（由硬件实现）来给每个进程它们自己的地址空间。RISC-V 页表翻译（或者叫映射）一个虚拟地址（RISC-V 指令操纵该地址）成一个物理地址（cpu芯片发送给主存储器到地址）。

&emsp;&emsp; Xv6 maintains a separate page table for each process that defines that process's address space. As illustrated in [[第2章#^e25637|Figure2.3]], an address space includes the process's *user memory* starting at virtual address zero. Instructions come first, followed by global variables, then the stack, and finally a "heap" area(for malloc) that the process can expand as needed. There are a number of factors that limit the maximum size of a process's address space: pointers on the RISC-V are 64 bits wide; the hardware only uses the low 39 bits when looking up virtual addresses in page tables; and xv6 only uses 38 of those 39 bits. Thus, the maximum address is $\mathsf{2^{38} -1 = 0X3fffffffff}$, which is MAXVA([kernel/risc.h:348](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/riscv.h#L348)). At the top of the address space xv6 reserves a page for *trampoline* and a page mapping the process's trapframe to switch to the kernel, as we will explain in Chapter 4.

&emsp;&emsp;xv6为每一个进程维持一个单独的页表（用来定义进程的地址空间）。如[[第2章#^e25637|图片2.3]]所示，一个地址空间包括进程的从虚拟地址的0号地址开始的用户内存。
首先是指令，然后依次是全局变量、栈、最后是堆（用于malloc），进程可以按需扩展。有大量的因素限制了一个进程的最大地址空间数：RISC-V中的指针有64位，但是在页表中寻找虚拟地址时，硬件只支持使用低39位，并xv6只使用38位。因此最大地址数是$\mathsf{2^{38} -1 = 0x3fffffffff}$,设置在MAXVA([kernel/risc.h:348](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/riscv.h#L348))这个常量中。在xv6地址空间的顶部，有一个页表用于*trampoline*以及一个页表用于进程的切换到内核陷阱帧，我们会在第4章介绍。
 
![[Pasted image 20211019173159.png]] ^e25637

&emsp;&emsp;The xv6 kernel maintains many pieces of state for each process, which it gathers into a *struct proc*([kernel/proc.h:86](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/proc.h#L86)). A process's most important pieces of kernel state are its page table, its kernel stack, and its run state. We'll use the notaion `p->xxx` to refer to elements of the `proc` structure; for example, `p->pagetable` is a pointer to the process's page table.

&emsp;&emsp;xv6内核为每个进程维持了很多状态，这些状态存在proc结构体中([kernel/proc.h:86](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/proc.h#L86))。在内核中，一个进程最重要的部分是页表、它的内核栈以及运行状态。我们将使用`p->xxx`这个标记来表示`proc`结构体的元素。比如，`p->pagetable`表示一个指向进程页表的指针。

&emsp;&emsp;Each process has a thread of execution(or *thread* for short) that executes the process's instructions. A thread can be suspended and later resumed. To switch transparently between processes, the kernel suspends the currently running thread and resumes another process's thread. Much of the state of a thread(local variables, function call return address) is stored on the thread's stacks. Each process has two stacks: a user stack and a kernel stack(`p->kstack`). When the process is executing user instructions, only its user stack is in use, and its kernel stack is empty. When the process enters the kernel(for a system call or interrupt), the kernel code executes on the process's kernel stack; while a process is in the kernel, its user stack still contains saved data, but isn't actively used. A process's thread alternates between actively using its user stack and its kernel stack. The kernel stack is separate(and protected from user code) so that the kernel can execute even if a process has wrecked its user stack.

&emsp;&emsp;每个进程有一个执行线程（或者简称线程），这个线程会执行进程的代码。一个线程能被暂停，然后恢复。 为了在进程间透明地切换，内核暂停正在运行的线程然后恢复另一个进程的线程。一个线程的大部分状态（本地变量，函数调用的返回值）被存放在线程栈中。每个进程有两个栈：用户栈和内核栈(`p->kstack`)。当进程执行用户指令时，只有用户栈被使用，内核栈此时是空的。当一个进程进入到内核（由于一个系统调用或者中断），内核代码会在进程的内核栈执行。当一个进程在内核中，它的用户栈仍然维持保存的数据，但是处于不活跃状态。一个进程的线程会频繁地在使用它的用户栈和使用它的内核栈交替。内核栈是分离的（并且不会被用户代码干扰），以便内核能执行，即使一个进程毁坏了它的用户栈。

&emsp;&emsp;A process can make a system call by executing the RISC-V `ecall` instruction. This instruction raises the hardware privilege level and changes the program counter to kernel-defined entry point. The code at the entry point switches to kernel stack and executes the kernel instructions that implement the system call. When the system call completes, the kernel switches back to the user stack and returns to user space by calling the *sret* instruction, which lowers the hardware privilege level and resumes executing user instructions just after the system call instruction. A process's thread can "block" in the kernel to wait for I/O, and resume where it left off when the I/O has finished.

&emsp;&emsp;一个进程能通过执行RISC-V的`ecall`来调用系统调用。这个指令提升硬件权限并改变程序计数器到被内核定义的进入点。在进入点的代码切换到内核栈中，并执行实现系统调用的内核指令。当系统调用执行完毕，内核会切换回用户栈并通过调用`sret`指令返回用户空间，然后降低硬件权限并恢复执行用户指令在系统调用指令之后。一个进程的线程会为了等待I/O而阻塞在内核中，并且会在I/O解说后恢复到离开的时候。

&emsp;&emsp;`p->state` indicates whether the process is allocated, ready to run, running, waiting for I/O, or exiting.

&emsp;&emsp;`p->state`表示进程是否被分配：准备运行，正在运行，等到I/O或者退出。

&emsp;&emsp;`p->pagetable` holds the process's page table, in the format that the RISC-V hardware expects. xv6 causes the paging hardware to use a process's `p->pagetable` when executing that process in user space. A process's page table also serves as the record of the addresses of the physical pages allocated to store the process's memory.

&emsp;&emsp;`p->pagetable` 持有进程的页表，以RISC-V硬件期望的形式。当执行用户空间的进程时，xv6会唤起分页硬件去使用进程的`p->pagetable`。一个进程的页表也有记录被分配用来存储进程内存的物理页的地址的作用。



## 2.6 Code: starting xv6 and the first process(代码：启动xv6和第一个进程)
To make xv6 more concrete, we'll outline how the kernel starts and runs the first process. The subsequent chapters will describe the mechanisms that show up in this overview in more detail.

为了使xv6更具体，我们会概述内核是如何启动以及如何允许第一个进程。这一小节将会更加细致的描述综述时出现的机制。

&emsp;&emsp;When the RISC-V computer powers on, it initializes itself and runs a boot loader which is stored in read-only memeory. The boot loader loads the xv6 kernel into memory. Then, in machine mode, the CPU executes xv6 kernel starting at `_entry`([kernel/entry.S:6](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/entry.S#L6)). The RISC-V starts with paging hardware disabled: virtual addresses map directly to physical addresses.

&emsp;&emsp;当RISC-V计算机启动，它会初始化自己然后允许一个存储在只读存储器里的启动装载器。这个启动装载器会将内核装载进内存。然后CPU会在机器模式下从`_entry`([kernel/entry.S:6](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/entry.S#L6))开始执行xv6内核。RISC-V刚启动时，分页硬件是不能使用的,这时候虚拟地址之间映射到物理地址。 

&emsp;&emsp;The loader loads the xv6 kernel into memory at physical $\mathsf{0x80000000}$. The reason it places the kernel at $\mathsf{0x80000000}$ rather than $\mathsf{0x0}$ is because the address range $\mathsf{0x0:0x80000000}$ contains I/O devics.

&emsp;&emsp;装载器将xv6内核装入物理内存$\mathsf{0x80000000}$。之所以不是从0号地址开始，是因为$\mathsf{0x0~0x80000000}$包含I/O设备。

&emsp;&emsp;The instructions at `_entry` set up a stack to that xv6 can run C code. Xv6 declares space for an initial stack, `stack0`, in the file `start.c`([kernel/start.c:11](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/start.c#L11)). The code at `_entry` loads the stack pointer register `sp` with the address `stack0+4096`, the top of the stack, because the stack on `RISC-V` grows down. Now that kernel has a stack, `_entry` calls into C code at `start`([kernel/start.c:21](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/start.c#L21)). 

&emsp;&emsp;`_entry`中的指令会设置一个栈，xv6的C代码能够运行在这个栈上。xv6为一个初始化的栈声明空间`stack0`，详细代码在文件`stack.c`([kernel/start.c:11](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/start.c#L11))。因为在RISC-V硬件上，栈是从栈顶往栈底生长，`_entry`的代码将栈指针寄存器`sp`赋值为地址`stack0+4096`。现在，内核有一个栈了，`_entry`调用c代码中的`start.c`([kernel/start.c:11](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/start.c#L21))。

&emsp;&emsp;The function `start` performs some configuration that is only allowed in machine mode, and then switches to supervisor mode. To enter supervisor mode, RISC-V provides the instruction `mret`. This instruction is most often used to return from a previous call from supervisor mode to machine mode. `start` isn't returning from such a call, and instead sets things up as if there had been one: it sets the previous privilege mode to supervisor in register `mstatus`, it sets the return address to `main` by writing `main`'s address into the register `mepc`, disables virtual address translation in supervisor mode by writing 0 into page-table register `stap`, and delegates all interrupts and exceptions to supervisor mode.

&emsp;&emsp;函数`start` 执行一些仅被允许在机器模式下才能执行的配置，然后切换到管理者模式。为了进入管理者模式，RISC-V 提供了一个指令`mret`。这个指令经常被用于返回之前的模式，一般是从管理者模式返回机器模式。`start` 不会从这样一个调用中返回，而是为了设置好像已经做了一件事：1）它将之前的特权模式设置成管理者模式（具体操作是设置`mstatus`寄存器），2）设置返回的地址为`main`函数（具体的方法是将其地址写入寄存器`mepc`），3）通过将0写入页表寄存器`satp`来禁止在管理者模式下的虚拟地址翻译，4）将所有的中断和异常委托给管理者模式。

&emsp;&emsp;Before jumping into supervisor mode, `start` performs one more task: it programs the clock chip to generate timer interrupts. With this housekeeping out of the way, `start` "returns" to supervisor mode by calling `mret`. This casues the program counter to change to `main`([kernel/main.c:11](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/main.c#L11)).

&emsp;&emsp;在跳进管理者模式前,`start`还会执行一个任务：控制时钟芯片形成一个时钟中断。在离开计算机处理后，`start`通过调用`mret`“返回”到`main`([kernel/main.c:11](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/main.c#L11))。

&emsp;&emsp;After `main`([kernel/main.c:11](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/main.c#L11))initializes several devices and subsystems, it creates the first process by calling `userinit`([kernel/proc.c:211](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/proc.c#L212)). The first process executes a small program written in RISC-V assembly, `initcode.S`([user/initcode.S:1](https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/initcode.S#L1)), which re-enters the kernel by invoking the `exec` system call. As we saw in Chapter 1, `exec` replaces the memory and registers of the current process with a new program(in this case, /init). Once the kernel has completed `exec`, it returns to user space in the `/init` process. `Init`([user/init.c:15](https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/init.c#L15))creates a new console device file if needed and then opens it as file descriptors 0, 1, and 2. Then it starts a shell on the console. The system is up.

&emsp;&emsp; 在 `main`([kernel/main.c:11](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/main.c#L11))函数初始化几个设备和子系统之后，会创建第一个进程叫做`userinit`([kernel/proc.c:211](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/proc.c#L212))。第一个程序会执行一个很小的程序，这个程序由RISC-V汇编编写，详细代码可见`initcode.S`([user/initcode.S:1](https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/initcode.S#L1))，这个程序通过调用`exec`系统调用来重新进入内核。如我们在第一章看到的，`exec`用一个新的程序(在这个例子中是/init)的代替现在进程的内存和寄存器。内核完成`exec`之后，它会返回用户进程中的`init`进程。`Init`([user/init.c:15](https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/init.c#L15))创建了一个新的控制台设备文件，然后作为文件描述符0，1，2打开。然后在控制台上打开一个shell。这个系统就启动了。
## 2.7 Real world
In the real world, one can find both monolithic kernels and microkernels. Many Unix kernels are monolithic. For example, Linux has a monolithic kernel, although some OS functions run as userlevel serves(e.g., the windowing system). Kernels such as L4, Minix, and QNX are organized as a microkernel with servers, and have seen wide deployment in embedded settings.

在真实世界中，宏内核和微内核都能找到。 许多Unix内核都是宏内核。比如，Linux有一个宏内核，虽然一些操作系统函数跑在用户级别的服务上（比如，视窗系统）。有些内核，比如L4，Minix以及QNX被组织成一个微内核，并在嵌入式设备广泛部署。

&emsp;&emsp;Most operating systems have adopted the process concept, and most processes look similar to xv6's. Modern operating systems, however, support several threads within a process, to allow a single process to exploit multiple CPUs. Supporting multiple threads in a process involves quite a bit of machinery that xv6 doesn't have, including potential interface changes(e.g., Linux's clone, a variant of fork), to control which aspects of a process threads share.

&emsp;&emsp;大部分操作系统已经采纳了进程的概念，并且大部分进程和xv6的类似。然而现代操作系统支持一个进程中包含多个线程，以便一个单一的进程能利用多个cpu。


## 2.8 exercieses

	