## Operating system organization(操作系统组织)
A key requirement for an operating system is to support several activities at once. For example, using the system call interface described in Chapter 1 a process can start new processes with fork. The operating system must *time-share* the resources of the computer among these processes. For example, even if there are more processes than there are hardware CPUs, the operating system must ensure that all of the processes get a chance to execute. The operating system must also arrange for isolation between the processes. That is, if one process has a bug and malfunctions, it shouldn't affect processes that don't depend on the buggy process. Complete isolation, however, is too strong, since it should be possible for processes to intentionally interact; pipelines are an example. Thus an operating system must fulfill three requirements: multiplexing, isolation, and interaction.

对于操作系统，必须支持多任务。比如，使用第一章描述的操作系统接口，一个进程可以通过`fork`开启一个新的进程. 操作系统必须在这些进程间实时共享计算机的资源。比如， 即使进程数多于硬件的CPU数，操作系统必须确保所有的进程都有机会执行。操作系统必须安排进程之间的隔离。因为，如果一个进程出现bug和故障，得保证这个有故障的进程不会影响到不依赖他的进程。但是完全的隔离太绝对了，因为进程间有可能会有意地进行相互影响。`管道(pipelines)`就是一个例子。因此一个操作系统必须满足三个需求：1)多任务 2)隔离 3)相互作用

&emsp;&emsp;This chapter provides an overview of how operating systems are organized to achieve these three requirements. It turns out there are many ways to do so, but this text focuses on mainstream designs centered around a *monolitihic kernel*, which is used by many Unix operating systems. This chapter also provides an overview of an xv6 process, which is the unit of isolation in xc6, and the creation of the first process when xv6 starts. 

&emsp;&emsp;这一章是对操作系统如何实现上述三个需求的一个综述。 事实证明有许多方法可以做到，但是这个文章聚焦于主流的设计，中心围绕`宏内核monolitihic kernel`，一个被许多Unix操作系统使用的内核。这一章也是概述了xv6 进程——xv6中的隔离单元，以及当xv6启动时第一个进程的创建。

&emsp;&emsp;Xv6 runs on a *multi-core* **RISC-V** microprocessor, and much of its low-level functionality(for example, its process implementation) is specific to **RISC-V**. **RISC-V** is a 64-bit CPU, and xv6 is writeen in "LP64" C, which means long(L) and pointers(P) in the C programming language are 64 bits, but int is 32-bit. This book assumes the reader has done a bit of machine-level programmming on some architecture, and will introduce **RISC-V-specific** ideas as they come up. A useful reference for **RISC-V** is "The RISC-V Reader: An Open Architecture Atals" [12]. The user-level ISA[2] and the privileged architecture [1] are the official specifications.

&emsp;&emsp;Xv6 跑在一个多核RISC-V 微处理器上，它的许多低级功能是争对RISC-V定制的(比如它的进程实现)。RISC-V是一个64位CPU，并且xv6被写在"LP64"C上，L64表示在C语言编程中，L(long)和P(pointers)是64位，但是int是32位。这本书假设读者有进行过些机器级别的编程，并且会介绍RISC-V-specific在之后遇见的时候。 对于RISC-V,一个有用的参考文献是"RISC-V的读者：一个开源架构集合"。这个用户级 ISA 和 特权架构是官方规格。

&emsp;&emsp;The CPU in a complete computer is surrounded by supoort hardware, much of it in the form of I/O interfaces. Xv6 is written for supoort hardware simulated by qemu's "-machine virt" option. This includes RAM, a ROM containing boot code, a serial connection to the user's key-board/screen, and a disk for storage.

&emsp;&emsp; 一个完整电脑上的CPU周围是其他支持该CPU的硬件，他们中的大部分以I/O接口的形式支持CPU。Xv6是用来支持被qemu模拟的硬件。这包括RAM，包含启动代码的ROM，一系列和用户鼠标/屏幕进行连接的部分以及一个用来存储的磁盘。

## 2.1 Abstracting physical resources
&emsp;&emsp;The first question one might ask when encountering an operating system is why have it at all? That is, one could implement the system calls in [[Figure 1.2]] as a library, with which applications link. In this plan, each application could even have its own library tailored to its needs. Applications could directly interact with hardware resources and use those resources in the best way for the application(e.g., to achieve high or predictable performance). Some operating systems for embedded devices or real-time systems are organized in this way.

&emsp;&emsp;人们遇到操作系统的第一个问题可能是为什么会有他呢？那是因为，它能够实现将第1章第2节中用过的的系统调用形成一个库，其他应用可以链接这个库从而使用系统调用。在这个计划中，每个应用设置可以通过需要裁剪他们自己的库。应用能直接和硬件资源进行交互以及用最好的方式使用这些资源(例如，可以实现效率高或者可预测的表现)。一些嵌入式设备上的操作系统或者实时操作系统以这种方式组织。

&emsp;&emsp;The downside of this library approcah is that, if there is more than one application running, the applications must be well-behaved. For example, each application must periodically give up the CPU so that other applications can run. Such a cooperative time-sharing scheme may be OK if all applications trust each other and have no bugs. It's more typical for applications to not trust each other, and to have bugs, so one often wants stronger isolation than cooperative scheme provides.

&emsp;&emsp;这个库方法的缺点是，如果有多个应用运行，这些应用必须表现良好。例如，每个应用必须定期地放弃占用CPU以便其他的应用能够运行。例如一个合作的分时策略可能成功，如果所有应用相互信任并且没有bug。但是一般应用之间并不会互相信任并且有不少bug，所以我们通常想要一个比合作策略隔离性更强的策略。

## 2.2 User mode,supervisor mode, and system calls

## 2.3 Kernel organization

## 2.4 Code: xv6 organization

## 2.5 Process overview

## 2.6 Code: starting xv6 and the first process

## 2.7 Real world

## 2.8 exercieses
