## Traps and system calls (陷阱和系统调用)

There are three kinds of event which cause the CPU to set aside ordinary execution of instructions and force a transfer of control to special code that handles the event. 

有三种`事件(event)`会导致CPU暂时搁置指令的普通执行并且强制将控制权转移到处理该事件的特殊代码。

One situation is a system call, when a user program executes the `ecall` instruction to ask the kernel to do something for it. 

第一种情况是`系统调用`, 当一个用户程序执行系统调用指令去访问内核时。

Another situation is an exception: an instruction (user or kernel) does something illegal, sucah as divide by zero or use invalid virtual address. 

另一种情况是`异常(exception)`: 一个指令（用户或者内核）做了一些非法操作，比如被0处或者使用无效的虚拟内存。

The third situation is a device interrupt, when a device signals that it needs attention, for example when the disk hardware finishes a read or write request.

第三种情况是`设备中断`，当一个设备发出信号表示他需要被注意，比如当磁盘硬件完成了读或写请求。

---
This book uses trap as a generic term for these situations. 

这本书用`陷阱(trap)`这一统一的术语来表示上面的三种情况。

Typically whatever code was executing at the time of the trap will later need to resume, and shouldn't need to be aware that anything special happened.

通常在遇到陷阱时，不论代码当时正在执行什么，陷阱结束之后，代码都必须复原，并且不需要感知到发生了什么特殊的事情。

That is, we often want traps to be transparent; this is paricularly important for interrupts, which the interrupted code typically doesn't expect.

那是因为，我们想让陷阱透明（计算机的透明指不被察觉）; 这一点对于中断尤为重要，因为被中断的代码通常不希望被中断。

The usual sequence is that a trap forces a transfer of control into the kernel; the kernel saves registers and other state so that execution can be resumed; the kernel excutes appropriate handler code(e.g., a system call implementation or decice driver); the kernel restores the saved state and returns from the trap; and the original code resumes where it left off.

通常的顺序是：
	1. 一个陷阱强制将控制权转移给内核 
	2. 内核保存寄存器和其他状态值以便执行能够复原 
	3. 内核执行合适的处理代码(例如，一个系统调用的实现或者设备驱动) 
	4. 内核恢复被保存的状态然后从陷阱返回，并且原始代码恢复到离开的时候的样子
	
---

&emsp;&emsp;The Xv6 kernel handles all traps. This is natural for system calls. It makes sense for interrupts since isolation demands that user processes not directly use devices, and because only the kernel has the state needed for device handling. It also makes sense for exceptions since xv6 responds to all exceptions from user space by killing the offending program.  

&emsp;&emsp;Xv6处理了所有的陷阱。 对于`系统调用`这很自然。对于`中断`，因为隔离要求用户进程不能直接使用设备，并且只有内核有需要设备处理的状态。对于`异常`，因为xv6通过杀死有问题的程序来响应所有的用户空间抛出的异常。

&emsp;&emsp;Xv6 trap handling proceeds in four stages: hardware actions taken by the RISC-V CPU, an assembly "vector" that prepares the way for kernel C code, a C trap handler that decides what to do with the trap, and the system call or device-driver service routine. While commonality among the three trap types suggests that a kernel could handle all traps with a single code path, it turns out to be convenient to have separate assembly vectors and C trap handlers for three distinct cases: traps from user space, traps from kernel space, and timer interrups.

&emsp;&emsp;Xv6 陷阱处理分为四个步骤：1)RISC-V CPU采取的硬件操作，为内核C代码准备的`汇编数组assembly vector`, 一个C陷阱处理器决定如何处理陷阱以及系统调用或者设备驱动服务程序。 虽然公平对待三种陷阱类型能使内核能够用一个代码处理所有的陷阱，但是结果证明对于三种不同的例子(来自用户空间的陷阱、来自内核空间的陷阱、时钟中断)，拥有单独的汇编数组和C陷阱处理代码更加方便。

### 4.1 RISC-V trap machinery(RISC-V陷阱体系)
Each RISC-V CPU has a set of control registers that the kernel writes to tell the CPU how to handle traps, and that the kernel can read to find out about a trap that has occured. The RISC-V documents contain the full story [1]. 


### 4.2 Traps from user space(来自用户空间的陷阱)
Chapter

### 4.3 Code: Calling system calls(代码：调用系统调用)

### 4.4 Code: System call arguments(代码：系统调用参数)